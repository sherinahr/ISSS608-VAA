---
title: "Mini Challenge 3 - VAST Challenge 2023"
author: "Sherinah Rashid"
date: '5 May 2023'
editor: visual
format:
  html: 
    code-fold: true
    code-summary: "Show code"
    code-overflow: wrap
    code-block-bg: true
    code-block-border-left: "#18661c"
execute:
  eval: true
  echo: true
  warning: false
  freeze: auto
---

# Background

This Take-Home Exercise is part of the VAST Challenge 2023. The country of Oceanus has sought FishEye International's help in identifying companies possibly engaged in illegal, unreported, and unregulated (IUU) fishing. They hope to understand business relationships, including finding links that will help them stop IUU fishing and protect marine species that are affected by it.

FishEye analysts have attempted to use traditional node-link visualizations and standard graph analyses, but these were found to be ineffective because the scale and detail in the data can obscure a business's true structure. FishEye now wants your help to develop a new visual analytics approach to better understand fishing business anomalies.

In line with this, this page will attempt to answer the following task under Mini-Challenge 3 of the VAST Challenge:

**Use visual analytics to identify anomalies in the business groups present in the knowledge graph. Limit your response to 400 words and 5 images.**

# Dataset

Fisheye has transformed the data into a undirected multi-graph consisting of 27,622 nodes and 24,038 edges. Details of the attributes provided are listed below:

**Nodes:**

-   **type** -- Possible node types include: {company and person}. Possible node sub types include: {beneficial owner, company contacts}.

-   **country** -- Country associated with the entity. This can be a full country or a two-letter country code.

-   **product_services** -- Description of product services that the "id" node does. 

-   **revenue_omu** -- Operating revenue of the "id" node in Oceanus Monetary Units. 

-   **id** -- Identifier of the node is also the name of the entry.

-   **role** -- The subset of the "type" node, not in every node attribute. 

-   **dataset** -- Always "MC3". 

**Links:**

-   **type** -- Possible edge types include: {person}. Possible edge sub types include: {beneficial owner, company contacts}.

-   **source** -- ID of the source node. 

-   **target** -- ID of the target node. 

-   **dataset** -- Always "MC3".

# Data Wrangling

## Data Import

Let's first load the packages and datasets to be used.

```{r}
pacman::p_load(jsonlite, tidygraph, ggraph, 
               visNetwork, graphlayouts, ggforce, 
               skimr, tidytext, tidyverse)
```

In the code chunk below, fromJSON() of jsonlite package is used to import MC3.json into R environment. Examination of the dataset shows that it is a large list R object.

```{r}
mc3_data <- fromJSON("data/MC3.json")
```

## Extracting Edges

The code chunk below will be used to extract the links data.frame of mc3_data and save it as a tibble data.frame called mc3_edges.

::: callout-note
-   `distinct()` is used to ensure that there will be no duplicated records.
-   `mutate()` and `as.character()` are used to convert the field data type from list to character.
-   `group_by()` and `summarise()` are used to count the number of unique links.
-   the `filter(source!=target)` is to ensure that there are no records with similar source and target.
:::

```{r}
mc3_edges <- as_tibble(mc3_data$links) %>% 
  distinct() %>%
  mutate(source = as.character(source),
         target = as.character(target),
         type = as.character(type)) %>%
  group_by(source, target, type) %>%
    summarise(weights = n()) %>%
  filter(source!=target) %>%
  ungroup()
```

## Extracting Nodes

The code chunk below will be used to extract the nodes data.frame of mc3_data and save it as a tibble data.frame called mc3_nodes.

::: callout-note
-   `mutate()` and `as.character()` are used to convert the field data type from list to character.
-   To convert *revenue_omu* from list data type to numeric data type, we need to convert the values into character first by using `as.character()`. Then, `as.numeric()` will be used to convert them into numeric data type.
-   `select()` is used to re-organise the order of the fields.
:::

```{r}
mc3_nodes <- as_tibble(mc3_data$nodes) %>%
  mutate(country = as.character(country),
         id = as.character(id),
         product_services = as.character(product_services),
         revenue_omu = as.numeric(as.character(revenue_omu)),
         type = as.character(type)) %>%
  select(id, country, type, revenue_omu, product_services)
```

# Initial Data Exploration

## Exploring the edges data frame

In the code chunk below, skim() of skimr package is used to display the summary statistics of mc3_edges tibble data frame. The report reveals that there is no missing values. However, though we had broken the MC3 data from its list, we can see from the max value of 700 under "source" that there may be grouped companies, up to 700 in 1 line! This will be tough for our analysis and so we have to break these nested lists down to the individual source companies.

```{r}
skim(mc3_edges)
```

Let's try unnest the lists. First, we will filter out the rows where there is nested lists. From looking at the data source in R console, we know that these values begins with "c(". From the results below, we can see there are 2,169 records which are nested.

```{r}
nested_edges <- mc3_edges %>%
  filter(startsWith(source, "c("))
nested_edges
```

First, we use separate_rows() to split the character vectors into separate elements based on the comma separator. Next, we remove leading and trailing whitespace using str_trim(). We then use the str_replace() function to remove the unwanted characters of ", (, and ). Lastly, we filter out any empty rows using filter(). Checking the filtered dataset shows that it worked!

```{r}
# Split the character vectors into separate elements
nested_edges_sep <- nested_edges %>%
  separate_rows(source, sep = ", ")

# Remove leading and trailing whitespace
nested_edges_sep <- nested_edges_sep %>%
  mutate(source = str_trim(source))

# Remove the c(), ", (, and ) characters
nested_edges_sep <- nested_edges_sep %>%
  mutate(source = gsub('^c\\(|"|\\)$', '', source))

# Check the end output
nested_edges_sep

```

To join the filtered dataset back with the original edges dataset, we will first remove the rows from the mc3_edges which were nested. We will then add in the filtered and unnested data. Since there's many repetitions of the companies, let's do some grouping. Lastly, let's use the skim function again to check the resulting dataset for the edges. It works out - the maximum length of the source has gone down to 64, yay!

```{r}

# Remove rows with nested records
edges <- mc3_edges %>%
  anti_join(nested_edges)

# Add in the filtered data 
edges <- edges %>%
  rbind(edges, nested_edges_sep)

# Group by source and target due to repetitions
edges_agg <- edges %>%
  group_by(source, target, type) %>%
  summarise(weight = n()) %>%
  filter(weight > 1) %>%
  ungroup() 

# Check output
skim(edges_agg)


```

In the code chunk below, datatable() of DT package is used to display the aggregated edges tibble data frame as an interactive table.

```{r}
DT::datatable(edges_agg)
```

Let's plot a bar graph to show the type of edges. As we can see from the barchart below, there are about 16,000 edges for beneficial owner, and about 7,500 edges for company contacts.

```{r}
ggplot(data = edges_agg,
       aes(x = type)) +
  geom_bar(fill="slategray1") + 
  theme_classic() 
```

## Exploring the nodes data frame

Similarly, skim() of skimr package is used to display the summary statistics of mc3_nodes tibble data frame. The report reveals that there is 21,515 missing values for revenue_omu variable.

```{r}
skim(mc3_nodes)
```

Let's check for duplicates using the distinct function.

```{r}
mc3_nodes_d <-distinct(mc3_nodes)

```

In the code chunk below, datatable() of DT package is used to display the distinct mc3_nodes tibble data frame as an interactive table. Initially, there were 27,622 rows and it has now reduced to 25,027 rows. There were about 2,000 duplicate rows.

```{r}
DT::datatable(mc3_nodes_d)
```

Let's plot a bar graph to show the type of edges. As we can see from the barchart below, there are about 10,000 nodes for beneficial owners, 8,750 nodes for company, and 6,000 nodes for company contacts.

```{r}
ggplot(data = mc3_nodes_d,
       aes(x = type)) +
  geom_bar(fill="slategray1") + 
  theme_classic() 
```

# Initial Network Visualisation and Analysis

Instead of using the nodes data table extracted from the original dataset, we will prepare a new nodes data table by using the source and target fields of the aggregated edges table. This is necessary to ensure that the nodes in the nodes data tables include all the source and target values.

```{r}
id1 <- edges_agg %>%
  select(source) %>%
  rename(id = source)
id2 <- edges_agg %>%
  select(target) %>%
  rename(id = target)
mc3_nodes1 <- rbind(id1, id2) %>%
  distinct() %>%
  left_join(mc3_nodes_d,
            unmatched = "drop")
```

We will then calculate the betweenness and closeness centrality measures.

```{r}
mc3_graph <- tbl_graph(nodes = mc3_nodes1,
                       edges = edges_agg,
                       directed = FALSE) %>%
  mutate(betweenness_centrality = centrality_betweenness(),
         closeness_centrality = centrality_closeness())
```

Now, let's plot the network graph using the tidygraph() function.

```{r}
mc3_graph %>%
  filter(betweenness_centrality >= 100000) %>%
ggraph(layout = "fr") +
  geom_edge_link(aes(alpha=0.5)) +
  geom_node_point(aes(
    size = betweenness_centrality,
    colors = "lightblue",
    alpha = 0.5)) +
  scale_size_continuous(range=c(1,10))+
  theme_graph()
```

# Making Sense of the Nodes??

Maybe we can see what categories there are for the nodes and then see if there is overlap

```{r}
categories <- mc3_nodes1 %>%
  count(product_services, sort = TRUE) %>%
  top_n(10)

# Printing the table
print(categories)
```
